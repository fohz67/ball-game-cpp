"use strict";(self.webpackChunkBall_Game_C_Documentation=self.webpackChunkBall_Game_C_Documentation||[]).push([[830],{7257:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>a,contentTitle:()=>t,default:()=>h,frontMatter:()=>r,metadata:()=>l,toc:()=>c});const l=JSON.parse('{"id":"server/mechanics","title":"Mechanics","description":"Overview","source":"@site/docs/server/mechanics.md","sourceDirName":"server","slug":"/server/mechanics","permalink":"/ball-game-cpp/docs/server/mechanics","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"title":"Mechanics","slug":"/server/mechanics"},"sidebar":"tutorialSidebar","previous":{"title":"Components","permalink":"/ball-game-cpp/docs/server/components"},"next":{"title":"Optimizations","permalink":"/ball-game-cpp/docs/server/optimizations"}}');var i=s(4848),o=s(8453);const r={title:"Mechanics",slug:"/server/mechanics"},t=void 0,a={},c=[{value:"Overview",id:"overview",level:2},{value:"1. Game Loop",id:"1-game-loop",level:2},{value:"Loop Execution Order:",id:"loop-execution-order",level:3},{value:"2. Cell Decay",id:"2-cell-decay",level:2},{value:"3. Collisions",id:"3-collisions",level:2},{value:"<strong>Cell-Cell Collisions</strong>",id:"cell-cell-collisions",level:3},{value:"<strong>Cell-Boundary Collisions</strong>",id:"cell-boundary-collisions",level:3},{value:"4. Eating Mechanics",id:"4-eating-mechanics",level:2},{value:"<strong>Pellet Consumption</strong>",id:"pellet-consumption",level:3},{value:"<strong>Player vs. Player Eating</strong>",id:"player-vs-player-eating",level:3},{value:"5. Fast Inverse Square Root (FIS)",id:"5-fast-inverse-square-root-fis",level:2},{value:"<strong>Why Use FIS?</strong>",id:"why-use-fis",level:3},{value:"<strong>Implementation</strong>",id:"implementation",level:3},{value:"6. Vector2 Operations",id:"6-vector2-operations",level:2},{value:"<strong>Core Operations</strong>",id:"core-operations",level:3},{value:"<strong>Example Use Cases</strong>",id:"example-use-cases",level:3},{value:"Conclusion",id:"conclusion",level:2}];function d(e){const n={code:"code",h2:"h2",h3:"h3",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,i.jsx)(n.p,{children:"This document provides an in-depth explanation of the core game mechanics, including the game loop, cell decay, collisions, eating mechanics, Fast Inverse Square Root (FIS), and vector calculations."}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"1-game-loop",children:"1. Game Loop"}),"\n",(0,i.jsxs)(n.p,{children:["The game operates on a continuous ",(0,i.jsx)(n.strong,{children:"update loop"})," that processes all game elements at a fixed interval. This loop ensures smooth gameplay by:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Updating player positions based on input (mouse movement or AI behavior)."}),"\n",(0,i.jsx)(n.li,{children:"Managing cell behavior, including movement, growth, and decay."}),"\n",(0,i.jsx)(n.li,{children:"Handling interactions like eating and collisions."}),"\n",(0,i.jsx)(n.li,{children:"Sending game state updates to clients."}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"loop-execution-order",children:"Loop Execution Order:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Update Cells:"})," Move cells, apply decay, and handle physics."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Process Collisions:"})," Check interactions between cells and resolve them."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Update Leaderboard:"})," Rank players based on their mass."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Send Network Updates:"})," Transmit the new game state to all connected clients."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Wait for Next Tick:"})," Maintain a consistent update rate to avoid lag."]}),"\n"]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"2-cell-decay",children:"2. Cell Decay"}),"\n",(0,i.jsxs)(n.p,{children:["Cells continuously ",(0,i.jsx)(n.strong,{children:"lose mass over time"})," to prevent infinite growth and keep the game balanced."]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"The decay rate is proportional to the cell's mass."}),"\n",(0,i.jsx)(n.li,{children:"The larger a cell, the faster it loses mass."}),"\n",(0,i.jsxs)(n.li,{children:["The decay function follows an ",(0,i.jsx)(n.strong,{children:"exponential decay curve"}),", reducing mass by a percentage each frame."]}),"\n",(0,i.jsxs)(n.li,{children:["If a cell\u2019s mass drops below a threshold, it reaches its ",(0,i.jsx)(n.strong,{children:"minimum playable size"}),"."]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Formula:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"NewMass = CurrentMass - (DecayRate * CurrentMass)\n"})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"3-collisions",children:"3. Collisions"}),"\n",(0,i.jsx)(n.p,{children:"Collisions are fundamental to cell interactions. The game processes collisions in two key ways:"}),"\n",(0,i.jsx)(n.h3,{id:"cell-cell-collisions",children:(0,i.jsx)(n.strong,{children:"Cell-Cell Collisions"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"A cell cannot pass through another."}),"\n",(0,i.jsx)(n.li,{children:"Larger cells can absorb smaller cells if they meet the eating conditions."}),"\n",(0,i.jsx)(n.li,{children:"Movement is restricted if two cells are overlapping to prevent clipping."}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"cell-boundary-collisions",children:(0,i.jsx)(n.strong,{children:"Cell-Boundary Collisions"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"The game world is a finite space with boundaries."}),"\n",(0,i.jsx)(n.li,{children:"If a cell reaches the world\u2019s edge, its movement is constrained."}),"\n",(0,i.jsx)(n.li,{children:"Collisions with the boundary adjust the cell\u2019s position to stay within the playable area."}),"\n"]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"4-eating-mechanics",children:"4. Eating Mechanics"}),"\n",(0,i.jsxs)(n.p,{children:["Cells can ",(0,i.jsx)(n.strong,{children:"consume"})," smaller entities to grow. The process follows these rules:"]}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Size Comparison:"})," A cell can only eat another if it is ",(0,i.jsx)(n.strong,{children:"significantly larger"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Distance Check:"})," The larger cell must be ",(0,i.jsx)(n.strong,{children:"close enough"})," to engulf the smaller one."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Mass Transfer:"})," The eaten cell's mass is added to the consuming cell."]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"pellet-consumption",children:(0,i.jsx)(n.strong,{children:"Pellet Consumption"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Small cells can eat ",(0,i.jsx)(n.strong,{children:"static pellets"})," spread across the map."]}),"\n",(0,i.jsx)(n.li,{children:"Pellets provide a small mass boost but do not alter gameplay significantly."}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"player-vs-player-eating",children:(0,i.jsx)(n.strong,{children:"Player vs. Player Eating"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["A cell must be ",(0,i.jsx)(n.strong,{children:"at least 1.25x larger"})," than another to consume it."]}),"\n",(0,i.jsx)(n.li,{children:"The mass of the eaten cell is added to the absorbing cell."}),"\n",(0,i.jsxs)(n.li,{children:["Eaten players are ",(0,i.jsx)(n.strong,{children:"eliminated"})," and must respawn."]}),"\n"]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"5-fast-inverse-square-root-fis",children:"5. Fast Inverse Square Root (FIS)"}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.strong,{children:"Fast Inverse Square Root"})," algorithm (FIS) is an optimized method to compute ",(0,i.jsx)(n.code,{children:"1 / sqrt(x)"}),", used for distance and magnitude calculations."]}),"\n",(0,i.jsx)(n.h3,{id:"why-use-fis",children:(0,i.jsx)(n.strong,{children:"Why Use FIS?"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Reduces CPU load compared to traditional ",(0,i.jsx)(n.code,{children:"sqrt()"})," calls."]}),"\n",(0,i.jsx)(n.li,{children:"Optimized using bit manipulation for near-instant computation."}),"\n",(0,i.jsx)(n.li,{children:"Used in distance normalization and movement calculations."}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"implementation",children:(0,i.jsx)(n.strong,{children:"Implementation"})}),"\n",(0,i.jsxs)(n.p,{children:["FIS uses a magic number (",(0,i.jsx)(n.code,{children:"0x5f3759df"}),") to estimate the inverse square root quickly:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"i = 0x5f3759df - (i >> 1); // Bit-level hack for sqrt approximation\n"})}),"\n",(0,i.jsx)(n.p,{children:"This method is used extensively in collision detection and vector normalization."}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"6-vector2-operations",children:"6. Vector2 Operations"}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"Vector2"})," class is essential for handling ",(0,i.jsx)(n.strong,{children:"positions, movement, and physics"}),"."]}),"\n",(0,i.jsx)(n.h3,{id:"core-operations",children:(0,i.jsx)(n.strong,{children:"Core Operations"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Addition & Subtraction:"})," Used to move objects."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Multiplication & Division:"})," Used for scaling movements."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Dot Product:"})," Measures the similarity of two vectors (e.g., direction checks)."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Normalization:"})," Converts a vector to a unit direction (used in movement logic)."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Magnitude:"})," Calculates the length of a vector, used in collision and distance calculations."]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"example-use-cases",children:(0,i.jsx)(n.strong,{children:"Example Use Cases"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Moving cells based on mouse input:"}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"Vector2 direction = (mousePosition - cellPosition).normalized();\ncellPosition += direction * cellSpeed;\n"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Checking if a cell can eat another:"}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"double distance = (cell1.position - cell2.position).magnitude();\nif (distance < cell1.radius - cell2.radius * 0.8) {\n    cell1.absorb(cell2);\n}\n"})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,i.jsxs)(n.p,{children:["These mechanics form the foundation of the game, ensuring fair play, competitive interactions, and smooth performance. The balance between ",(0,i.jsx)(n.strong,{children:"growth, decay, and collisions"})," creates engaging gameplay where players must strategically ",(0,i.jsx)(n.strong,{children:"navigate, consume, and survive"})," in the ever-changing world."]})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>r,x:()=>t});var l=s(6540);const i={},o=l.createContext(i);function r(e){const n=l.useContext(o);return l.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function t(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),l.createElement(o.Provider,{value:n},e.children)}}}]);