"use strict";(self.webpackChunkBall_Game_C_Documentation=self.webpackChunkBall_Game_C_Documentation||[]).push([[32],{9481:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>o,contentTitle:()=>a,default:()=>h,frontMatter:()=>l,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"server/optimizations","title":"Optimizations","description":"This document provides an in-depth explanation of how memory management, threading, object pooling, and performance optimizations are handled in the game server.","source":"@site/docs/server/optimizations.md","sourceDirName":"server","slug":"/server/optimizations","permalink":"/docs/server/optimizations","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"title":"Optimizations","slug":"/server/optimizations"},"sidebar":"tutorialSidebar","previous":{"title":"Mechanics","permalink":"/docs/server/mechanics"},"next":{"title":"Configuration","permalink":"/docs/server/config"}}');var r=i(4848),t=i(8453);const l={title:"Optimizations",slug:"/server/optimizations"},a=void 0,o={},d=[{value:"Memory Management",id:"memory-management",level:2},{value:"Threading Model",id:"threading-model",level:2},{value:"Object Pooling and Optimizations",id:"object-pooling-and-optimizations",level:2},{value:"<strong>1. Object Pooling</strong>",id:"1-object-pooling",level:3},{value:"<strong>2. Packet Batching</strong>",id:"2-packet-batching",level:3},{value:"<strong>3. Reduced Redundant Updates</strong>",id:"3-reduced-redundant-updates",level:3},{value:"<strong>4. Efficient Collision Handling</strong>",id:"4-efficient-collision-handling",level:3},{value:"<strong>5. AI Performance Considerations</strong>",id:"5-ai-performance-considerations",level:3},{value:"Summary",id:"summary",level:2}];function c(e){const n={code:"code",h2:"h2",h3:"h3",hr:"hr",li:"li",p:"p",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.p,{children:"This document provides an in-depth explanation of how memory management, threading, object pooling, and performance optimizations are handled in the game server."}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"memory-management",children:"Memory Management"}),"\n",(0,r.jsx)(n.p,{children:"The server ensures efficient memory usage by:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"AtomicID Management:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["The ",(0,r.jsx)(n.code,{children:"AtomicID"})," system generates unique identifiers for game entities while allowing efficient ID reuse. When an entity is deleted, its ID is pushed onto a ",(0,r.jsx)(n.code,{children:"recycledIds"})," stack to be reused instead of creating new IDs unnecessarily."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"SmartBuffer Serialization:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["The ",(0,r.jsx)(n.code,{children:"SmartBuffer"})," class handles message serialization, reducing memory fragmentation and ensuring efficient data packing when sending network packets."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Object Lifetime Management:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Entities such as players and cells are stored in STL containers (",(0,r.jsx)(n.code,{children:"std::vector"}),", ",(0,r.jsx)(n.code,{children:"std::unordered_map"}),")."]}),"\n",(0,r.jsxs)(n.li,{children:["Players are managed via ",(0,r.jsx)(n.code,{children:"PlayerManager"}),", while cells and pellets are managed in ",(0,r.jsx)(n.code,{children:"CellManager"}),"."]}),"\n",(0,r.jsx)(n.li,{children:"Players and entities are dynamically allocated and freed efficiently to avoid memory leaks."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Memory Cleanup:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Objects (players, cells, pellets) are explicitly removed using ",(0,r.jsx)(n.code,{children:"removePlayer()"})," and ",(0,r.jsx)(n.code,{children:"deleteCells()"})," when they are no longer needed."]}),"\n",(0,r.jsxs)(n.li,{children:["The server ensures that ",(0,r.jsx)(n.code,{children:"AtomicID::removeId()"})," is called to mark an ID for reuse."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"threading-model",children:"Threading Model"}),"\n",(0,r.jsx)(n.p,{children:"The server utilizes multi-threading for performance, preventing blocking operations from degrading game performance. The main components of the threading model include:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Main Game Thread"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["The core simulation loop runs in a separate thread (",(0,r.jsx)(n.code,{children:"Game::updateThread"}),"), handling physics updates, leaderboard calculations, and bot AI."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Network Thread"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["The ASIO networking library (",(0,r.jsx)(n.code,{children:"Network::run()"}),") runs in its own thread, handling TCP client connections asynchronously."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"asyncRead()"})," listens for incoming packets and processes them without blocking."]}),"\n",(0,r.jsxs)(n.li,{children:["The ",(0,r.jsx)(n.code,{children:"sendLoop()"})," thread sends update messages to all clients at a fixed rate."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Game Logic Thread"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["The ",(0,r.jsx)(n.code,{children:"updateLoop()"})," thread manages game state updates, including movement, decay, and interactions."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Worker Thread for AI Bots"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Bot behavior (",(0,r.jsx)(n.code,{children:"AI::computeAIMovement()"}),") is calculated in the main game loop without blocking other operations."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"object-pooling-and-optimizations",children:"Object Pooling and Optimizations"}),"\n",(0,r.jsx)(n.p,{children:"The game server implements various optimizations to ensure high performance and scalability:"}),"\n",(0,r.jsx)(n.h3,{id:"1-object-pooling",children:(0,r.jsx)(n.strong,{children:"1. Object Pooling"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Instead of continuously allocating and deallocating game objects, objects are recycled."}),"\n",(0,r.jsxs)(n.li,{children:["The ",(0,r.jsx)(n.code,{children:"AtomicID"})," system allows ID reuse to prevent excessive allocation."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"CellManager"})," maintains an active list of cells and reuses pellet IDs when they are deleted."]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"2-packet-batching",children:(0,r.jsx)(n.strong,{children:"2. Packet Batching"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["The ",(0,r.jsx)(n.code,{children:"SmartBuffer"})," ensures that multiple game updates are combined into fewer packets to reduce network overhead."]}),"\n",(0,r.jsxs)(n.li,{children:["The server prevents exceeding ",(0,r.jsx)(n.code,{children:"Config::Network::MAX_SIZE"})," by flushing packets before they exceed the limit."]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"3-reduced-redundant-updates",children:(0,r.jsx)(n.strong,{children:"3. Reduced Redundant Updates"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Leaderboard updates and other infrequent state changes are only sent when necessary (",(0,r.jsx)(n.code,{children:"Send::sendUpdateLeaderboard()"}),")."]}),"\n",(0,r.jsx)(n.li,{children:"Pellets are respawned in batches instead of one-by-one for better efficiency."}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"4-efficient-collision-handling",children:(0,r.jsx)(n.strong,{children:"4. Efficient Collision Handling"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Instead of checking every cell against every other cell (",(0,r.jsx)(n.code,{children:"O(n^2)"})," complexity), cell updates are done in a structured order, avoiding redundant calculations."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"Eat::RESOLVE_FACTOR"})," prevents excessive collision resolution calls."]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"5-ai-performance-considerations",children:(0,r.jsx)(n.strong,{children:"5. AI Performance Considerations"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Bot movement calculations occur every update but prioritize larger threats and targets to reduce unnecessary checks."}),"\n",(0,r.jsx)(n.li,{children:"AI decisions are cached and updated at controlled intervals to prevent excess CPU usage."}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["The server uses ",(0,r.jsx)(n.strong,{children:"multi-threading"})," to handle network, game logic, and AI separately."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Memory-efficient ID reuse"})," via ",(0,r.jsx)(n.code,{children:"AtomicID"})," prevents excessive allocation/deallocation."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Object pooling"})," optimizes pellets and cells, preventing frequent new allocations."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"SmartBuffer optimizes network traffic"})," by batching messages efficiently."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Physics and AI are optimized"})," to ensure smooth gameplay at scale."]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"These techniques ensure that the game server remains scalable, performant, and responsive, even with multiple concurrent players."})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>l,x:()=>a});var s=i(6540);const r={},t=s.createContext(r);function l(e){const n=s.useContext(t);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:l(e.components),s.createElement(t.Provider,{value:n},e.children)}}}]);