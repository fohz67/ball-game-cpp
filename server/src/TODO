/*void CellManager::updateCellMovement(uint32_t ownerId, float normMouseX, float normMouseY) {
    std::vector<Cell*> playerCells = getPlayerCells(ownerId);
    if (playerCells.empty()) return;
    float centerX = 0.0f, centerY = 0.0f;
    for (const auto* cell : playerCells) {
        centerX += cell->getX();
        centerY += cell->getY();
    }
    centerX /= playerCells.size();
    centerY /= playerCells.size();
    float dirX = normMouseX;
    float dirY = normMouseY;
    if (std::fabs(dirX) < 0.05f) dirX = 0;
    if (std::fabs(dirY) < 0.05f) dirY = 0;
    for (auto* cell : playerCells) {
        float radius = cell->getRadius();
        float speed = 100.0f / std::log(radius + 1.5f);
        float newX = cell->getX() + dirX * speed;
        float newY = cell->getY() + dirY * speed;
        for (auto* otherCell : playerCells) {
            if (cell == otherCell) continue;
            float dx = newX - otherCell->getX();
            float dy = newY - otherCell->getY();
            float distance = std::sqrt(dx * dx + dy * dy);
            float minDist = radius + otherCell->getRadius();

            if (distance < minDist) {
                float overlap = minDist - distance;
                newX += dx / distance * overlap * 0.5f;
                newY += dy / distance * overlap * 0.5f;
            }
        }
        cell->setPosition(newX, newY);
    }
}
*/

/*
std::pair<float, float> CellManager::calculateViewport(uint32_t ownerId) {
    std::vector<Cell*> playerCells;
    float centerX = 0.0f, centerY = 0.0f;
    for (auto& cell : cells) {
        if (cell.getOwnerId() == ownerId) {
            playerCells.push_back(&cell);
        }
    }
    if (playerCells.empty()) {
        return {0, 0};
    }
    for (const auto* cell : playerCells) {
        centerX += cell->getX();
        centerY += cell->getY();
    }
    centerX /= playerCells.size();
    centerY /= playerCells.size();
    return {centerX, centerY};
}
*/